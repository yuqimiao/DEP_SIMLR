---
title: "simulation_notebook"
author: "yuqimiao"
date: "2022-09-30"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

```{r}
library(tidyverse)
# need to connect to cluster
```

## 220930 4 clusters

**Basic setting: **

The setting is to have 4 clusters in total. Dataset 1 separates clusters (1+2) from 3, and 4. Dataset 2 separates clusters 1, 2 and (3+4). That is, using dataset 1 or 2 only, you can detect 3 clusters, although 2 sets of three different clusters. Only when you use both datasets 1 and 2, you can detect 4 clusters. This way, the overlapping information of the 2 datasets are, clusters (1+2) from clusters (3+4). The unique information of dataset 1 is to separate cluster 1 and 2. The unique information of dataset 2 is to separate cluster 3 and 4.

**Parameters: **

* n_feat1 = 1000
* n_feat2 = 100000
* mu1 = c(0, 0, 1, -1)
* mu2 = c(1,-1,0,0)

```{r}
# data read in
dir = "/Volumes/sw2206/yuqi/simu_220930"
# files = list.files(dir)
# tib_all = NULL
# for(i in 1:length(files)){
#   tib = readRDS(paste(dir,"/", files[i], sep = ""))
#   tib_all = rbind(tib_all, tib)
# }
# saveRDS(tib_all, paste(dir, "/all_data.rds", sep = ""))
tib_all = readRDS(paste(dir, "/all_data.rds", sep = ""))

tib_all %>% unnest(res_tib) %>% 
  group_by(noise_sd, kernel, method) %>% 
  summarize(mean_nmi = mean(nmi),
         sd_nmi = sd(nmi)) %>% 
  mutate(kernel = factor(kernel, levels = c("kernel", "diff_kernel"))) %>% 
  ggplot(aes(x = noise_sd, y = mean_nmi, color = method))+
  geom_line(aes(linetype=kernel, color = method))+
  # geom_errorbar(aes(ymin=mean_nmi-sd_nmi, ymax=mean_nmi+sd_nmi), width=.2)
  geom_point()
```

From above, we can see that the diffusion actually decrease the performance of part-cimlr when the noise is large. One potential improvement is to update the eigenvector used for single data partition information. 

## 220930-extension 4 cluster

Here we extend the 4 cluster scenario in 220930 in terms of the following terms:
1. Trial of part-cimlr with the update_c, i.e, with only informative eigenvecros as partition information, to see if the performance of the diffusion version of part-cimlr is improving
2. Extend the noise_sd to see the overall performance: noise_sd_all = c(1, 1.25, 1.75, 2, 2.25, 2.5, 2.75, 3, 3.25, 3.5, 3.75, 4)

```{r}
# data read in
dir = "/Volumes/sw2206/yuqi/simu_220930_2"
# files = list.files(dir)
# tib_all = NULL
# for(i in 1:length(files)){
#   tib = readRDS(paste(dir,"/", files[i], sep = ""))
#   tib_all = rbind(tib_all, tib)
# }
# saveRDS(tib_all, paste(dir, "/all_data.rds", sep = ""))

tib_all = readRDS(paste(dir, "/all_data.rds", sep = ""))

tib_all %>% unnest(res_tib) %>% 
  group_by(noise_sd, kernel, method) %>% 
  summarize(mean_nmi = mean(nmi),
         sd_nmi = sd(nmi)) %>% 
  mutate(kernel = factor(kernel, levels = c("kernel", "diff_kernel"))) %>% 
  ggplot(aes(x = noise_sd, y = mean_nmi, color = method))+
  geom_line(aes(linetype=kernel, color = method))+
  # geom_errorbar(aes(ymin=mean_nmi-sd_nmi, ymax=mean_nmi+sd_nmi), width=.2)
  geom_point()
```

From the simulation result, we can see that the performance of part_cimlr_up has a sharp drop when the noise_sd increase to 3.25 from 3. I start a new notebook [here](choose_eigenvec_number.html) to illustrate the possible reasons and improvement. In a word, once we want to use eigenvector to represents the similarity matrix/GL matrix, we need to use eigengap to find the eigenvectors actually contains information. 

But when the information contained in the data is vague, the eigen gap is invalid. The max gap is occured randomly. Thus we need to further explore the eigenvectors to use as partition information. Currently reading Dataspectropy, Shi, 2009

# 221012 4 clusters

From the simulation above, we see the effect of diffusion and partition cimlr. But how each strategy contributes is still a bit vague. In this simulation, we aim to verify our 2 assumption on the effect of 2 strategies:

1. Diffusion helps denoise on the single data level, capturing the larger, clearer structure
2. Partition-level integration can help to handle the heterogeneity of dimensions in different data types

## 221012_1 effect of diffusion

```{r}
dir = "/Volumes/sw2206/yuqi/simu_221012_1"
# files = list.files(dir)
# tib_all = NULL
# for(i in 1:length(files)){
#   tib = readRDS(paste(dir,"/", files[i], sep = ""))
#   tib_all = rbind(tib_all, tib)
# }
# saveRDS(tib_all, paste(dir, "/all_data.rds", sep = ""))

tib_all = readRDS(paste(dir, "/all_data.rds", sep = ""))
```

```{r}
tib_all %>% 
  group_by(n_feat, noise_sd, kernel_type) %>% 
  summarize(mean_nmi = mean(nmi)) %>% 
  ggplot(aes(x = noise_sd, y = mean_nmi, color = kernel_type, group = kernel_type))+
  geom_line()+
  geom_point()+
  facet_grid(n_feat~.)
```


## 221012_2 effect of partition-level 

```{r}
dir = "/Volumes/sw2206/yuqi/simu_221012_2"
# dir = "simu_221012_2"
# files = list.files(dir)
# tib_all = NULL
# for(i in 1:length(files)){
#   file_cur = paste(dir,"/", files[i], sep = "")
#   if(file.exists(file_cur)){
#     tib = readRDS(file_cur) %>% unnest(res_tib) %>% dplyr::select(-res_list)
#     tib_all = rbind(tib_all, tib)
#     print(i)
#   }else{
#     print(paste("file",file_cur,"does not exist!!!!!"))
#   }
# }
# saveRDS(tib_all, paste(dir, "/all_data.rds", sep = ""))

tib_all = readRDS(paste(dir, "/all_data.rds", sep = ""))
```

```{r}
simu_tib = simu_tib =tibble(scenario = 1:4,
                 n_feat1 = c(1000, 1000, 10000, 1000),
                 n_feat2 = c(10000, 100000, 100000, 10000),
                 n_feat3 = c(NA,NA,NA, 100000)) %>%
  mutate(tib = map(scenario, function(s){
    tibble(noise_sd = seq(1,5,0.25))
  })) %>% unnest(tib) %>%
  mutate(scenario = seq_along(scenario))


mean_tib = tib_all %>% 
  mutate(simu_id = (simu_id-1)%/%100+1) %>% 
  left_join(simu_tib, by = c("simu_id" = "scenario")) %>% 
  mutate(noise_sd = noise_sd.x, kernel_type = kernel) %>% 
  dplyr::select(-noise_sd.y, -kernel) %>% 
  group_by(n_feat1,n_feat2, n_feat3, noise_sd, kernel_type, method) %>% 
  summarize(mean_nmi = mean(nmi)) %>% 
  mutate(comb = ifelse(is.na(n_feat3), paste(n_feat1, n_feat2, sep = "-"), paste(n_feat1, n_feat2, n_feat3, sep = "-")))
```

2 data integration, with increasing noise sd
```{r}
mean_tib %>% 
  filter(comb!="1000-10000-1e+05") %>% 
  filter(method!="part_cimlr_up") %>% 
  ggplot(aes(x = noise_sd, y = mean_nmi, color = method))+
  geom_line(aes(linetype=kernel_type, color = method))+
  geom_point()+
  facet_wrap(~comb, nrow = 1)
```

2 data integration v.s. 3 data integration
```{r}
mean_tib %>% 
  filter(comb %in% c("1000-10000","1000-10000-1e+05")) %>% 
  filter(method!="part_cimlr_up") %>%
  ggplot(aes(x = noise_sd, y = mean_nmi, color = method))+
  geom_line(aes(linetype=kernel_type, color = method))+
  geom_point()+
  facet_wrap(~comb, nrow = 1)
```



